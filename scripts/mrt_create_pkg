#!/bin/bash

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                                                                       #
# = = = = = = = = = = = = = = = = = = MRT CREATE CATKING PACKAGE= = = = = = = = = = = = #
#                                                                                       #
# Author:   Claudio Bandera		                                                		#
# Date:     2015-07-06                                                                  #
# Version:  0.1 																		#
# License:  																			#
#                                                                                       #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Beschreibung 
#
#

################################## INTERNE VARIABLEN ####################################

OPTIONS="$@" # Optionen für zweiten getopts-Aufruf sichern
SELF="$(readlink /proc/$$/fd/255)" || SELF="$0" # Eigener Pfad (besseres $0)
SELF_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
TYPE=""
USE_ROS=false
CREATE_REPO=false
BASE_PATH=$PWD
###################################### FUNKTIONEN #######################################

func_exit() {                             # Beenden und aufräumen
	[ -n "${exfrom[*]}" ] && rm ${exfrom[*]}
	exit 1
}

func_get_userinfo() {
	func_git_error() {
		echo  "$(tput setaf 1)ERROR: Please install git and configure your username and email adress.$(tput sgr0)"
		echo "You can do this with:"
		echo ">sudo apt-get install git"
		echo ">git config --global user.name 'FIRSTNAME LASTNAME'"
		echo ">git config --global user.email EMAIL@ADRESS.DOMAIN"
		func_exit
	}
	
	# Check wether git is installed
	if ! dpkg -s git > /dev/null 2>&1; then
		func_git_error
	fi
	
	# Read out username and email
	USR_NAME=$(git config --get user.name)
	USR_EMAIL=$(git config --get user.email)
	
	# Check wether git is configured
	if [ -z "$USR_NAME" ]||[ -z "$USR_EMAIL" ]; then
		func_git_error
	fi
}

func_create_directories() {
	# Check for already existing folder
	if [ -d src/$PKG_NAME ]; then
		echo  "$(tput setaf 1)ERROR$(tput sgr0): The folder with the name ./src/"$PKG_NAME" exists already. Please move it or choose a different package name."
		func_exit
	fi
	
	# Create folders
	mkdir -p src/$PKG_NAME
	cd src/$PKG_NAME
	mkdir -p src include/$PKG_NAME/internal test 
	if $USE_ROS && [ $TYPE = "exec" ]; then
		mkdir -p res launch/params;
	fi
	
	# Readme
	cp $SELF_DIR/../templates/README.md .
	
	# Library Header
	touch include/$PKG_NAME/$PKG_NAME.h
	
}

func_create_files() {
	# Create files and replace with user info
	# Package.xml
	if $USE_ROS; then
		cp $SELF_DIR/../templates/package_ros.xml package.xml
	else
		cp $SELF_DIR/../templates/package.xml package.xml
	fi
	
	sed -i -e "s/\${PACKAGE_NAME}/$PKG_NAME/g" -e "s/\${CMAKE_PACKAGE_NAME}/${PKG_NAME^^}/g" -e "s/\${USER_NAME}/$USR_NAME/g" -e "s/\${USER_EMAIL}/$USR_EMAIL/g" package.xml
	
	# CMakeLists.txt
	#build mask @12345@
	#pos1: non ros package
	#pos2: ros package
	#pos3: header only library
	#pos4: library
	#pos5: executable
	PATTERN="@"
	if $USE_ROS; then
		PATTERN="${PATTERN}x."
	else
		PATTERN="${PATTERN}.x"
	fi
	
	case $TYPE in
		lib)
			PATTERN="${PATTERN}x..@"
			;;
		hlib) 
			PATTERN="${PATTERN}.x.@"
			;;
		exec) 
			PATTERN="${PATTERN}..x@"
			;;
		*) echo "$(tput setaf 1)ERROR:$(tput sgr0) Option for type not valid."; func_exit;;       
	esac
	
	cp $SELF_DIR/../templates/CMakeLists.txt CMakeLists.txt
	sed -i -e "s/^$PATTERN //g" -e "/^@.....@/d" -e "s/\${CMAKE_PACKAGE_NAME}/${PKG_NAME}/g" CMakeLists.txt
}


func_create_repository() {
	if $CREATE_REPO; then
		# API call is handled by python script
		REPO_URL=$(python $SELF_DIR/mrt_create_repo.py $PKG_NAME) 
		if [ -z "$REPO_URL" ]; then
			echo "$(tput setaf 1)ERROR$(tput sgr0) could not create gitlab repository. Skipping repo setup"
			return
		fi
		
		# Initialize repository
		cd $BASE_PATH/src/$PKG_NAME
		git init 
		git remote add origin $REPO_URL >/dev/null 2>&1
		git add . >/dev/null 2>&1
		git commit -m "Initial commit" >/dev/null 2>&1
		git push -u origin master >/dev/null 2>&1
		
		# Register with rosdep
		if [ ! -f "$BASE_PATH/src/.rosinstall" ]; then
			echo "Initializing wstool in ./src"
			wstool init $BASE_PATH/src >/dev/null 2>&1
		fi
		wstool set $PKG_NAME --git $REPO_URL --confirm -t $BASE_PATH/src >/dev/null 
	fi
	if $USE_ROS; then # no package.xml otherwise
		sed -i -e "s#\${PACKAGE_REPOSITORY_URL}#$REPO_URL#g" $BASE_PATH/src/$PKG_NAME/package.xml # Using hashtag instead of / because REPO_URL contains them aswell
	fi
}

func_check_naming() {
	while [ -z "$PKG_NAME" ] || [[ ! $PKG_NAME =~ ^[a-z_]+$ ]] || [[ ! $(echo $PKG_NAME | head -c 1) =~ ^[a-z]+$ ]]; do # only lowercase and underscore allowed
		read -p "Please enter a package name containing only [a-z] and _ (First char must be a letter): " PKG_NAME
	done
}

# Help
func_help() {
	usage="
Usage: $(basename "$0") [-t type] [-rg] [PACKAGE_NAME]-- script to create catkin package

where:
	-h  show this help text
	-t  Type of package {lib|hlib|exec}
	-g  Create gitlab repository (optional)
	-r  Make ROS-Package (optional)
"
  echo "$usage"
func_exit
}

##################################### KONFIG LADEN ######################################
# Handle option flags
OPTIND=1
while getopts "ht:rg" opt; do # set $opt to the next passed option
  case $opt in
    h) func_help;;
    t) 
      TYPE=$OPTARG
      case $OPTARG in
		  lib) ;;
		  hlib) ;;
		  exec) ;;
		  *) echo "$(tput setaf 1)ERROR:$(tput sgr0) Option for type not valid."; func_exit;;       
      esac;;
    r) USE_ROS=true;;
	g) CREATE_REPO=true;;
    *) echo "$(tput setaf 1)ERROR:$(tput sgr0) Option not valid."; func_exit;;       
  esac
done

# Handle non-option argument
shift $(($OPTIND - 1)) # $1 is now the first non-option argument, $2 the second, etc
PKG_NAME=$1

#########INTERACTIVE MODE##################
# Check wether no arguments were passed
if [ $OPTIND -eq 1 ] || [ -z "$TYPE" ]; then 
	#clear;
	echo $(basename "$0")
	echo
	echo "Not all options were passed, starting interactive mode."; 
	echo
	# PKG_NAME
	func_check_naming
	
	# CREATE_REPO
	while true; do     
       read -p "Do you want to create a gitlab repository?: [y/N]" yn 
	   yn="${yn:=n}" # Default answer
       case ${yn^^} in      
            [Y]* ) CREATE_REPO=true; break;;   
            [N]* ) CREATE_REPO=false; break;;  
            * ) echo "$(tput setf 1)Please answer yes or no.$(tput sgr0)";;   
        esac  
    done     
	
	# USE_ROS
	while true; do    
		read -p "Do you want to create a ROS Package?: [y/N]" yn
		yn="${yn:=n}"
		case ${yn^^} in 
			[Y]* ) USE_ROS=true; break;;
			[N]* ) USE_ROS=false; break;;
			* ) echo "$(tput setf 1)Please answer yes or no.$(tput sgr0)";;   
		esac  
    done 
	
	# TYPE
	echo "What kind of package do you want to create?"
	echo "(1) library"
	echo "(2) header-only library"
	echo "(3) executable"
	while true; do    
       read -p "Choose Number: " yn
       case ${yn} in 
            [1]* ) TYPE="lib"; break;;
            [2]* ) TYPE="hlib"; break;;
            [3]* ) TYPE="exec"; break;;
            * ) echo "$(tput setf 1)Please enter a number from 1-3.$(tput sgr0)";;   
        esac  
    done 
fi
		
# Adjust package name
func_check_naming
if [ $TYPE = "exec" ]; then
	PKG_NAME=$PKG_NAME"_tool";
fi
if $USE_ROS; then
	PKG_NAME=$PKG_NAME"_ros";
fi


echo $PKG_NAME  
######################################### START #########################################

func_get_userinfo
echo "Creating package with name.... $(tput bold)$PKG_NAME$(tput sgr0)" >&2
echo "     --> Package type.... $TYPE" >&2
echo -n "     --> Create ROS Package.... "; ($USE_ROS && echo "$(tput setaf 2)YES$(tput sgr0)" || echo "$(tput setaf 1)NO$(tput sgr0)")
echo -n "     --> Create gitlab repository.... "; ($CREATE_REPO && echo "$(tput setaf 2)YES$(tput sgr0)" || echo "$(tput setaf 1)NO$(tput sgr0)")
echo "     --> Package Maintainer.... $USR_NAME <$USR_EMAIL>" >&2
echo
func_create_directories
func_create_files
func_create_repository
